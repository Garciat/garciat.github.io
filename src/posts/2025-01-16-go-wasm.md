---
title: "Compiling Go to WASM"
date: 2025-01-16
description: "I share my experience compiling Go to WASM for a side project."
---

## Background

Last year a wrote [a type-checker for Golang](https://github.com/garciat/gobid)
(written in Go) whose aim is to expand the language's type inference
capabilities by using
[bidirectional typechecking](https://ncatlab.org/nlab/show/bidirectional+typechecking).
(It's just a small "what if" experiment.)

It was my first experience with that technique. In retrospect, I think I did a
decent job but I am sure I did not grasp the concept fully at the time. For
example, I would've liked to split my AST in the way that Conor McBride
describes in
[this talk on type systems](https://youtu.be/21bUrFEX4jI?si=vCzErmbIYeGPQjK9&t=1585).

As I developed the type-checker, I found myself repeatedly clearing my terminal
screen and re-running the tool to check its output. My write-run-debug loop was
inefficient. So I put together a tiny web app.

The web app consisted of a frontend and a backend. The **frontend** makes use of
[Monaco Editor](https://microsoft.github.io/monaco-editor/) to display two code
editors side by side (_a la_ [Compiler Explorer](https://godbolt.org/)) -- one
to edit the source Go code and one to display the tool's output. The **backend**
receives `POST /compile` requests from the frontend every time the user edits
the source code; the input is the user's code as text, and the output is the
type-checker's internal logs.

Admittedly, I spent too much time on this (I have a weak spot for webdev), but
it worked out pretty well.

...and it wasn't long before I wanted to share my work with friends and
colleagues ðŸ˜„. So I used [Google Cloud Run](https://cloud.google.com/run)'s free
tier to build and deploy the app, which gave me access to
[a public URL for the app](https://gobid-922992323762.us-central1.run.app/).

For the time being, I was satisfied with all the work that I did. And I moved
on.

Fast forward to a few weeks ago...

During the holidays, I had enough time and energy to finally pour some love into
my personal website. It had been neglected for years, and one of the reasons for
such neglect was my annoyance of working with Ruby and
[Jekyll](https://jekyllrb.com/). I just found it clunky and uninteresting.

On my search for alternative static site generators, I found
[Lume](https://lume.land/). It is a dead-simple, batteries-included framework
that _just works_. But more importantly, it _just makes sense_. I was instantly
delighted, so I spent the following days moving every site that I own (mainly
GitHub Pages) to Lume. I had lots of fun and was extremely productive using
Deno, Lume, TypeScript, and Preact.

And then it hit me: What if I don't need a backend for my type-checker web app?
Could I also turn it into a statically-built website?

The answer was yes. I was able to replace the backend call with a direct call to
the type-checker compiled as [WASM](https://webassembly.org/). That allowed me
to get rid of the Google Cloud deployment and simply build the app with Lume and
deploy it for free to GitHub Pages.

So, that's the _why_. Now, let's focus on the _how_.

The rest of this post will detail:

- What I did to make this work.
- My opinion about the current state of Golang's support for WASM.
- Possible improvements or workarounds for the issues that I found.

## Compiling and running

(Note: I'm currently running Go version `1.23.4`.)

Compiling Go to WASM ([docs](https://go.dev/wiki/WebAssembly)) is pleasantly
simple and easy:

```bash
GOOS=js GOARCH=wasm go build -o build/main.wasm github.com/garciat/gobid/cmd/main
```

To my surprise, the command ran successfully on the first try without any
changes at all to the codebase. Props to the Golang dev team.

Now, how do we get this running?

[The documentation](https://go.dev/wiki/WebAssembly#getting-started) asks us to
copy the file `"$(go env GOROOT)/misc/wasm/wasm_exec.js"` into our project and
to import it as a helper script:

```html
<script src="wasm_exec.js"></script>
<script>
  const go = new Go();
  WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
    .then((result) => {
      go.run(result.instance);
    });
</script>
```

I do so, and it works. I see the following logged into the developer console:

```
wasm_exec.js:22 === CheckPackageDeclarations ===
wasm_exec.js:22 === CheckPackageCycles ===
wasm_exec.js:22 === ResolvePackageNames(main) ===
wasm_exec.js:22 === Loading Package (main) ===
wasm_exec.js:22 === Checking Package (main) ===
wasm_exec.js:22 === Verifying Package (main) ===
wasm_exec.js:22 === Verify ===
wasm_exec.js:22 === iteration 0 ===
wasm_exec.js:22 Context:
{} || {}
wasm_exec.js:22 Steps:
wasm_exec.js:22 === DONE ===
wasm_exec.js:22 {{  }}
```

This tells me that the code ran all the way through successfully. Great.

Is that it? No. Not at all.

My tool's `main` executable is meant to be called with file paths passed as
commandline arguments. For example:

```bash
go run github.com/garciat/gobid/cmd/main hello.go
```

I need to be able to:

1. Provide program arguments. (`os.Args`)
2. Provide readable files.
3. Capture `stdout` into a JS string, instead of `console.log`.

I could skip points (1.) and (2.) by changing the program to read from `stdin`
instead. That would be good enough for an MVP. But for whatever reason I chose
to stick to its original behavior. How hard could that be?

## Providing program arguments

This is actually easy to do:

```javascript
const go = new Go();
go.argv.push("hello.go");
// ...
```

But how did I figure that out?
[Go's official documentation for WebAssembly](https://go.dev/wiki/WebAssembly)
does not document what the `wasm_exec.js` file contains, or what the API for its
`Go` object is.

Our only options are to either
[read the file itself](https://github.com/golang/go/blob/go1.23.4/misc/wasm/wasm_exec.js)
to infer its API, or to read the code of one of the many provided
[example apps](https://go.dev/wiki/WebAssembly#further-examples).

As we'll see further on, this will not be our last problem with
_underspecification_.

## Providing readable files

The `wasm_exec.js` support file
([link](https://github.com/golang/go/blob/go1.23.4/misc/wasm/wasm_exec.js#L14))
gives us a hint as to how filesystem access works in Go-WASM:

```javascript
if (!globalThis.fs) {
  let outputBuf = "";
  globalThis.fs = {
    constants: {/** */},
    writeSync(fd, buf) {
      outputBuf += decoder.decode(buf);
      const nl = outputBuf.lastIndexOf("\n");
      if (nl != -1) {
        console.log(outputBuf.substring(0, nl));
        outputBuf = outputBuf.substring(nl + 1);
      }
      return buf.length;
    },
    // Several more methods like:
    // write, chmod, chown, etc.
  };
}
```

That piece of code seems to be defining a Node.js-like filesystem interface. But
there are essentially zero direct source references to `fs` in the
`wasm_exec.js` file itself. How is this being used then?

The Go standard library file `src/syscall/fs_js.go`
([link](https://github.com/golang/go/blob/go1.23.4/src/syscall/fs_js.go)) reads
the `fs` global variable like so:

```go
// NOTE: some lines were redacted away for brevity

package syscall

import (
  "syscall/js"
)

var jsFS = js.Global().Get("fs")
var constants = jsFS.Get("constants")

func Ftruncate(fd int, length int64) error {
  _, err := fsCall("ftruncate", fd, length)
  return err
}

func fsCall(name string, args ...any) (js.Value, error) {
  type callResult struct {
    val js.Value
    err error
  }

  c := make(chan callResult, 1)
  f := js.FuncOf(func(this js.Value, args []js.Value) any {
    var res callResult

    if len(args) >= 1 { // on Node.js 8, fs.utimes calls the callback without any arguments
      if jsErr := args[0]; !jsErr.IsNull() {
        res.err = mapJSError(jsErr)
      }
    }

    res.val = js.Undefined()
    if len(args) >= 2 {
      res.val = args[1]
    }

    c <- res
    return nil
  })
  defer f.Release()
  jsFS.Call(name, append(args, f)...)
  res := <-c
  return res.val, res.err
}
```

From this, we may infer the following:

- Go expects a global name `fs`.
- Go redirects filesystem syscalls to method calls on `fs`.
- The syscall API mimicks Node.js's [fs module](https://nodejs.org/api/fs.html).
  - Go relies on specific overloads of each function.
  - For example: Node.js's `fs.ftruncate`
    ([link](https://nodejs.org/api/fs.html#fsftruncatefd-len-callback)) may be
    called with `fd, callback` or with `fd, len, callback`, but Go only uses the
    `fd, len, callback` overload.
- All syscalls are callback-based.
  - The Go callback specifically expects `null` when there is no error. I.e.
    `undefined` or some other falsey value will not do.

## Conclusion
