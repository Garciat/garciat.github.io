---
layout:     post
title:      "Java Pattern: Algebraic Data Types"
date:       2020-05-07
---

I find Algebraic Data Types (ADTs) to be a powerful domain modeling tool.

TODO: explain why :)

## Prerequisites

  - Familiarize yourself with the [Lombok library](https://projectlombok.org/). In particular, its [Value feature](https://projectlombok.org/features/Value) to build immutable data types.
  
  - Assume that `null` is **not admissible** for any field, parameter, etc. **unless** it is marked with `@Nullable`.

## TL;DR

Given ADT like:

```
MyType = Case1(FieldType1_1 field1_1, ...) | Case2(FieldType2_1 field2_1, ...) | ...
```

Its direct translation to Java is:

```
public abstract class MyType {

  private Type() {}

  public abstract <R> R accept(Visitor<R> visitor);

  public interface Visitor<R> {
    R visit(Case1 cursor);
    R visit(Case2 cursor);
    ...
  }

  @Value
  public static class Case1 extends MyType {
    
    FieldType1_1 field1_1;
    ... (fields of Case1)
  
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  @Value
  public static class Case2 extends MyType {
    
    FieldType2_1 field2_1;
    ... (fields of Case2)
    
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  ... (cases)
}
```

## The use case

Let's say we are writing a backend application that returns a paginated list of transactions:

```java
@Value
class Page {
  List<Transaction> transactions;
}
```

To implement pagination, we return an opaque cursor to the client:

```java
@Value
class Page {
  List<Transaction> transactions;
  String cursor;
}
```

This cursor can be passed in by the client to fetch the next page:

```java
// assume this is the RPC interface of our service
class TransactionFeedService {
  Page getTransactions(String cursor);
}
```

Now, we already have two issues:

  1. How will clients fetch the first page of transactions, if the `String cursor` is a required input?
  2. How can we signal the client that it has reached the end of the feed?

`@Nullable` to the rescue!

```java
@Value
class Page {
  List<Transaction> transactions;
  /**
   * `null` indicates the end of the feed.
   */
  @Nullable String cursor;
}

class TransactionFeedService {
  /**
   * When `cursor == null`, the first page of the feed is fetched.
   */
  Page getTransactions(@Nullable String cursor);
}
```

Great (:

We have extended the range of admissible values of our input and output types to include `null`. To clarify the semantics of `null` in our domain, we made use of docstrings.

This presents the following issues:

  1. We must now check for `null`s. And if we forget to, we'll encounter `NullPointerException`s. (Granted: some IDEs or static analysis may be able to mitigate this issue.)
  2. We rely on docstrings to give semantics to our domain.

Enter ADTs!

Let's start off with a dedicated type for cursors:

```java
public abstract class Cursor {

}
```

Now, let's think about the types of cursor we need.

  1. A cursor that corresponds to the start of the feed.
  2. A cursor that contains an opaque value that can be used to fetch the next page in the feed.
  3. A cursor that corresponds to the end of the feed.

Let's write that down:

```java
public abstract class Cursor {

  private Cursor() {}

  @Value
  public static class Start extends Cursor {}
  
  @Value
  public static class Next extends Cursor {
    String value;
  }
  
  @Value
  public static class End extends Cursor {}
}
```

Indeed, `new Cursor.Start()` is-a `Cursor`, as are `new Cursor.Next("magic value in here")` and `new Cursor.End()`.

Let's update our service interface:

```java
@Value
class Page {
  List<Transaction> transactions;
  Cursor cursor;
}

class TransactionFeedService {
  Page getTransactions(Cursor cursor);
}
```

Perfect. We got rid of the `null` state and the docstrings. Is that it?

Well, yes and no.

Within our service code, we will end up writing something like:

```java
List<Transaction> transactions;

if (cursor instanceof Cursor.Next) {
  transactions = fetchWithCursor(((Cursor.Next) cursor).getValue());
} else if (cursor instanceof Cursor.Start) {
  transactions = fetchFirstPage();
} else if (cursor instanceof Cursor.End) {
  throw new IllegalArgumentException("cannot request end of feed");
} else {
  // but... we know there are no other cursor types
  // serves as a fallback in case we add a new cursor type and forget to handle it
  throw new IllegalStateException("unknown cursor type");
}
```

This is (arguably) a bit clunky. Also: imagine that we added a new cursor type. It would be easy to forget the if-check for this new cursor type. (Perhaps in this contrived example this seems unlikely, but consider a data type with more alternatives.)

Enter the (modified) visitor pattern!

```java
public abstract class Cursor {

  private Cursor() {}

  public abstract <R> R accept(Visitor<R> visitor);

  public interface Visitor<R> {
    R visit(Start cursor);
    R visit(Next cursor);
    R visit(End cursor);
  }

  @Value
  public static class Start extends Cursor {
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  @Value
  public static class Next extends Cursor {
    String value;
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  @Value
  public static class End extends Cursor {
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
}
```

Now, we can write:

```java
List<Transaction> transactions =
  cursor.accept(new Cursor.Visitor<List<Transaction>>() {
    @Override
    public List<Transaction> visit(Cursor.Start cursor) {
      return fetchFirstPage();
    }
    @Override
    public List<Transaction> visit(Cursor.Next cursor) {
      return fetchWithCursor(cursor.getValue()); // no cast !
    }
    @Override
    public List<Transaction> visit(Cursor.End cursor) {
      throw new IllegalArgumentException("cannot request end of feed");
    }
  });
```

Notice how there is no more `IllegalStateException`, because the `Visitor` knows exactly which cursor types exist.

Also, notice how it is _impossible_ to add a new cursor type without updating the rest of the code. For example:
  1. You add a new inner `static class NewThing extends Cursor`.
  2. You are forced to implement the abstract method `accept`.
  3. To implement `accept`, you must add a new `visit(NewThing cursor)` method to the `Visitor` interface.
  4. You must now update all the code that calls `Cursor::accept`, because their `Visitor` implementations are now lacking this new method.

The above is an example of type-guided programming! The code will not compile unless the system remains coherent. I'd argue this is a good property to have.

Moving on.

We still need to handle that pesky `IllegalArgumentException`, though. Why?

Because we conflated input and output cursors from the get-go:
  1. It does not make sense for an input cursor to be of type `End`.
  2. It does not make sense for an output cursor to be of type `Start`.

Before we tackle this issue, let me introduce a bit of abstract syntax to describe ADTs concisely.

Our current `Cursor` type can be described as:

```haskell
Cursor = Start | Next(String value) | End
```

I think the meaning of this is self-evident.

Now, let's split the cursor type:

```haskell
InputCursor = Start | Next(String value)
OutputCursor = Next(String value) | End
```

Cool. Let's reify that in Java code:

```java
public abstract class InputCursor {

  private InputCursor() {}

  public abstract <R> R accept(Visitor<R> visitor);

  public interface Visitor<R> {
    R visit(Start cursor);
    R visit(Next cursor);
  }

  @Value
  public static class Start extends InputCursor {
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  @Value
  public static class Next extends InputCursor {
    String value;
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
}
```

and

```java
public abstract class OutputCursor {

  private OutputCursor() {}

  public abstract <R> R accept(Visitor<R> visitor);

  public interface Visitor<R> {
    R visit(Next cursor);
    R visit(End cursor);
  }

  @Value
  public static class Next extends OutputCursor {
    String value;
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
  
  @Value
  public static class End extends OutputCursor {
    @Override
    public <R> R accept(Visitor<R> visitor) {
      return visitor.visit(this);
    }
  }
}
```

Note that although both are 'cursors', the types actually have no relationship between each other.

Now, our service interface can be updated:

```java
@Value
class Page {
  List<Transaction> transactions;
  OutputCursor cursor;
}

class TransactionFeedService {
  Page getTransactions(InputCursor cursor);
}
```

Along with the service code snippet:

```java
List<Transaction> transactions =
  cursor.accept(new InputCursor.Visitor<List<Transaction>>() {
    @Override
    public List<Transaction> visit(InputCursor.Start cursor) {
      return fetchFirstPage();
    }
    @Override
    public List<Transaction> visit(InputCursor.Next cursor) {
      return fetchWithCursor(cursor.getValue()); // no cast !
    }
  });
```

Great! No more illegal or unexpected states.

TODO: variant of the pattern where the base type is an `interface`.
